---
title: "Joining several data frames with `dplyr`"
author: "Silvie Cinkov√°"
date: 2025-08-09
echo: true
shift-heading-level-by: -1
format:
  revealjs:
    plugins: [notes]
    toc: true
    slide-number: true
    notes: true
    pdf-export: true
    css: atrium.css
    chalkboard: false
    scrollable: true
    code-block-height: 650px
    echo: true
    #output-location: slide
    preview-links: auto
  pdf:
    toc: true
    number-sections: true
    include-in-header: atrium.tex
  html:
    toc: true
    number-sections: true
    css: atrium.css
    embed-resources: true
---
## Join tables by a shared column

![](images_ATRIUM/SQL-table-schema-showing-the-relations-between-the-tables-in-the-complete-editing_W640.jpg)

::: notes
-   Relational databases: tables connected by shared columns. Useful with big datasets evolving in time, in separate places, etc. Two main assets:
    1)  A change propagates automatically to all places where relevant
    2)  On-demand tables generated by queries (variability depends on how smart the connections between tables are).\
-   Each table = **entity** (*wiki page*, *user*), **category** (lists of categories of users and categories of pages) or **event**/**state** (*revision*, *userincategory*) in the domain described. Intelligible table names!!!, distinction of type not important.\
-   Relations between tables: tables are joined by *key columns* (*primary key* unique id of each row vs. *foreign key* - corresponding primary key of a different table)
-   image by Marian-Andrei Rizoiu, article *Evolution of Privacy Loss in Wikipedia*, 2015, about Revision history versioning in Wikipedia.
:::

## Revision performed by a user

![](images_ATRIUM/SQL-revision-user.jpg)

::: notes
-   Revision table with columns `id`, `page_id`, `user_id`,`timestamp`, , `parentid`,`text`.
-   primary key: unique `id` of each revision.
-   `page_id` foreign key - turquoise arrow leads to a *page* table, to its primary key (probably called `id` but potentially anything else)
-   `user_id` foreign key - purple arrow leads to a *user* table
-   `timestamp`:when the revision took place
-   `parentid`: the id of the previous revision - to look up on a different row in the same table
:::

## Revision performed on a wiki page

![](images_ATRIUM/SQL_revision-page.jpg)

You can e.g. easily generate a table with revisions of one particular page.

::: notes
-   start with the `revision` table : `page_id` is foreign key, arrow leads to the page table, column `id`. Other columns: `title`, `namespace`, `creation_date`, `last_edit_date` (possibly fills in automatically from the revision table, but that's not important now), etc.
-   to the `page` table leads an arrow from the `pageincategory` table, which is just a hub connecting the pages table with the categories table.
:::

## Connecting tables

![](images_ATRIUM/SQL-table-schema-showing-the-relations-between-the-tables-in-the-complete-editing_W640.jpg)

::: notes
-   Tables `userincategory` and `pageincategory` assign users and pages to categories. The lime arrow from usercategory ought to start in `category_id`, not `user_id`
-   Pagecategories and usercategories have hierarchies among themselves, described by the `subcategory` table. So the category names are all in one table and changes to their hierarchy are made in the `subcategory` table. Again, the `level` column in `xxcategory` probably fills out automatically with a change in the `subcategory` table.
:::

## `gapminder`

```{r}
#| echo: false
#| warning: false
#| message: false
library(dplyr)
library(gapminder)
library(readr)
library(stringr)
library(magrittr)
library(stringdist)
library(fuzzyjoin)
glimpse(gapminder)
```

## `geo`

```{r}
geo <- read_csv("https://raw.githubusercontent.com/open-numbers/ddf--gapminder--fasttrack/master/ddf--entities--geo--country.csv")
geo <- geo %>% select(country, name, main_religion_2008, income_3groups)
glimpse(geo)
```

## Countries in `geo` vs. `gapminder`

```{r}
unique(geo$name) %>% length()
```

```{r}
unique(gapminder$country) %>% length()
```

## Overlap in key column values not full?

```{r}
setdiff(gapminder$country, geo$name)
```

```{r}
setdiff(geo$name, gapminder$country)
```

## Control key values selection

![](images_ATRIUM/joins.png){width="120%" height="200%"}

::: notes
Imagine two data sets: `gapminder` extract of year 2007 and `geo`. Both contain a column with country names, but `gapminder` lists fewer countries. It is up to you whether you want to have just `gapminder` countries or just `geo` countries or just complete cases with values in both tables or all countries including those with values from either table missing.
:::

## Age at first marriage women

"https://www.gapminder.org/data/"

```{=html}
<iframe width="780" height="500" src="https://www.gapminder.org/data/" title="Data from Gapminder.org"></iframe>
```
## Age at first marriage women

```{r}
library(gsheet)
a <- gsheet::construct_download_url("https://docs.google.com/spreadsheets/d/1xYQ08p5llwPR3ZK6h900LDd-J7WuXCv_FoPlksrj-eA/pub#")
firstmarriage <- gsheet::gsheet2tbl(a)
glimpse(firstmarriage)
```

```{r}
firstmarriage <- firstmarriage %>% select(1, `2005`) %>% rename(country = `...1`)
glimpse(firstmarriage)
```

```{r}
#| echo: false
write_csv(firstmarriage, "gapminder_firstmarriage.csv")
```

## Gapminder datasets in CSV

https://github.com/open-numbers/ddf--gapminder--systema_globalis/tree/master/countries-etc-datapoints

![](images_ATRIUM/Screenshot_githubgapminder.png)

## When your observations are not unique

```{r echo=FALSE}
maths <- tibble(#id = c("a01", "a02", "a03", "a04"), 
                name = c("John Smith", "Mary Brown", 
                         "John Smith", "Helene Field"), 
                
                birthplace = c("Honolulu", "Milan", "Prague", "Beijing"), 
                math_test = c(72, 40, 25, 91)
                )

social_sciences <- tibble(#id =  c("a02", "a01", "a03", "a04"), 
                          name = c("Mary Brown", "John Smith", "John Smith",
                                   "Helene Field"), 
                          birthplace = c("Milan", "Honolulu", 
                                         "Prague", "Beijing"), 
                          soc_test = c(12, 5, 76, 49)
                          
                          )
```

```{r}
maths
```

```{r}
social_sciences
```

::: notes
Students' grades in two courses. You would like to have both exams in the same table. Are the students uniquely identified?
:::

## Possible rescue: unique by several columns

```{r}
left_join(maths, social_sciences, by = (c("name", "birthplace")))
```

## No chance to join

If you cannot find anything that makes them unique.

```{r warning=TRUE}
maths2 <- select(maths, -birthplace)
social_sciences2 <- select(social_sciences, !birthplace)
left_join(maths2, social_sciences2, by = "name")
```

::: notes
Note John Smith occurring four times - all possible combinations get generated.
:::

## `dplyr::join` help

explore the arguments

-   `relationship`

-   `multiple`

-   `unmatched`

## Data with typos in the key column(s)

-   libraries `fuzzyjoin` along with `stringdist` (used by `fuzzyjoin`)

-   DataCamp course **Intermediate Regular Expressions in R \> Similarities Between Strings**

## JRC Names

Steinberger Ralf, Bruno Pouliquen, Mijail Kabadjov, Jenya Belyaeva & Erik van der Goot (2011).**JRC-Names: A freely available, highly multilingual named entity resource**. Proceedings of the 8th International Conference Recent Advances in Natural Language Processing (RANLP). Hissar, Bulgaria, 12-14 September 2011.

```{r echo=FALSE}
library(data.table)
jrc <- fread(file = "datasets_ATRIUM/JRC_Names/JRC_Names.tsv", skip = 1, col.names = c("id", "PersOrg", "name"), drop=3) 
jrc_latin <- jrc[str_detect(name, regex("^(\\p{IsLatin}|\\p{IsPunctuation}|\\p{IsSymbol}|\\p{IsMark})+$"))]
jrc_count <- jrc_latin[, n := .N, by = id]
jrc_latin %>% write_tsv("datasets_ATRIUM/JRC_Names/jrc_latin.tsv")
jrc_lac <- jrc_latin[n == 4]
jrc_lac %>% write_tsv("datasets_ATRIUM/jrc_latin_4.tsv")
jrc_lac %<>% group_by(id) %>% mutate(index_id = 1:n()) %>% ungroup()
jrc_1 <- jrc_lac %>% filter(index_id == 1) %>% arrange(id) %>% slice(1:20)
jrc_2 <- jrc_lac %>% filter(index_id == 2) %>% arrange(id) %>% slice(1:20)
jrc_3 <- jrc_lac %>% filter(index_id == 3) %>% arrange(id) %>% slice(1:20)
jrc_4 <- jrc_lac %>% filter(index_id == 3) %>% arrange(id) %>% slice(1:20)
#write_tsv(jrc_1, "JRC_Names/jrc_1.tsv")
#write_tsv(jrc_2, "JRC_Names/jrc_2.tsv")
#write_tsv(jrc_3, "JRC_Names/jrc_3.tsv")
#write_tsv(jrc_4, "JRC_Names/jrc_4.tsv")
```

## Matching on Levenschtein Distance

```{r}
joinJRC_lv <- fuzzyjoin::stringdist_left_join(x = jrc_1, y = jrc_2, 
                                         distance_col = "distance", 
                                         by = "name", 
                                         ignore_case = TRUE,
                                         method = "lv",
                                         #q = 1,
                                         max_dist = 2) %>% 
  relocate(name.x, name.y, distance) 
joinJRC_lv
```

## Matching on qgrams

-   q-grams aka n-grams: rolling substrings of a given length

-   bigrams (2-grams) of **fish:** *fi - is - sh*

-   trigrams (3-grams) of **fish**: *fis - ish*

```{r}
stringdist_semi_join(x = jrc_1, y = jrc_2, 
                                         distance_col = "distance", 
                                         by = "name", 
                                         ignore_case = TRUE,
                                         method = "qgram",
                                         q = 3,
                                         max_dist = 5)
stringdist_anti_join(x = jrc_1, y = jrc_2, 
                                         distance_col = "distance", 
                                         by = "name", 
                                         ignore_case = TRUE,
                                         method = "qgram",
                                         q = 3,
                                         max_dist = 5)
```

## Matching on cosine distance between qgrams

```{r eval=TRUE}
joinJRC12_cosine <- fuzzyjoin::stringdist_inner_join(x = jrc_1, y = jrc_2, distance_col = "distance",
          by = "name", ignore_case = TRUE, 
           method = "cosine",
          q = 1,
          max_dist = 0.15,
          ) %>% relocate(name.x, name.y, distance) 
joinJRC12_cosine
```

## Matching on Jaccard distance

```{r eval=FALSE}
joinJRC12_jaccard <- fuzzyjoin::stringdist_inner_join(x = jrc_1, y = jrc_2, distance_col = "distance",
          by = "name", ignore_case = TRUE, 
           method = "jaccard",
          q = 1,
          max_dist = 0.18,
          ) %>% relocate(name.x, name.y, distance) 
joinJRC12_jaccard
```
